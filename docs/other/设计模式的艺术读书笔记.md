> 模式名称与使用频率～


![image.png](https://cdn.nlark.com/yuque/0/2024/png/21883277/1705769593579-5a0600ea-0000-481e-9125-50d1e2f02e88.png#averageHue=%23f3f3f3&clientId=u9616b4c4-f126-4&from=paste&height=704&id=u1f92ee23&originHeight=1408&originWidth=988&originalType=binary&ratio=2&rotation=0&showTitle=false&size=512723&status=done&style=none&taskId=ub8b7e793-42fb-47a2-92cc-0dddc4f9d36&title=&width=494)

本书所采用的讲解实例和练习实例如下表所示。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21883277/1705769626999-f64e1142-4d28-4043-81a6-6fc36fb3a619.png#averageHue=%23ededed&clientId=u9616b4c4-f126-4&from=paste&height=710&id=udca20aa0&originHeight=1420&originWidth=1332&originalType=binary&ratio=2&rotation=0&showTitle=false&size=946102&status=done&style=none&taskId=u56132e61-04f3-4e2e-b0f7-0c185f544df&title=&width=666)
# 创建的艺术～创建型模式
> 创建型模式将对象的创建和使用分离，在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。每个创建型模式都通过采用不同的解决方案来回答3个问题：创建什么（What），由谁创建（Who）和何时创建（When）。

##  确保对象的唯一性～单例模式
### 饿汉单例
![](https://cdn.nlark.com/yuque/__puml/f4621179358891b23d6603718d07142a.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcbmNsYXNzIFNpbmdsZXRvbiB7XG4gIC0gc3RhdGljIGluc3RhbmNlID0gbmV3IFNpbmdsZXRvblxuICArIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBTaW5nbGV0b25cbiAgKyBvcGVyYXRpb24oKTogdm9pZFxufVxuU2luZ2xldG9uIC0tPiBTaW5nbGV0b24gOiBnZXRJbnN0YW5jZSgpXG5AZW5kdW1sIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC9mNDYyMTE3OTM1ODg5MWIyM2Q2NjAzNzE4ZDA3MTQyYS5zdmciLCJpZCI6Ik52M05KIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==)

### 懒汉单例

- 懒汉加锁
![](https://cdn.nlark.com/yuque/__puml/0e0c6022ca34327bbff9ef625fa28952.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcbmNsYXNzIFNpbmdsZXRvbiB7XG4gIC0gc3RhdGljIHZvbGF0aWxlIGluc3RhbmNlID0gbnVsbFxuICAtIGNvbnN0cnVjdG9yOiBTaW5nbGV0b25cbiAgKyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogc3luY2hyb25pemVkIFNpbmdsZXRvblxuICArIG9wZXJhdGlvbigpOiB2b2lkXG59XG5ub3RlIGxlZnQgb2YgU2luZ2xldG9uOjpnZXRJbnN0YW5jZVxuaWYgKGluc3RhbmNlID09IG51bGwpXG5cdGluc3RhbmNlID0gY29uc3RydWN0KCk7XG5yZXR1cm4gaW5zdGFuY2U7XG5lbmQgbm90ZVxuU2luZ2xldG9uIC0tPiBTaW5nbGV0b24gOiBnZXRJbnN0YW5jZSgpXG5AZW5kdW1sIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC8wZTBjNjAyMmNhMzQzMjdiYmZmOWVmNjI1ZmEyODk1Mi5zdmciLCJpZCI6InBsdWFZIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==)
- 懒汉双重检测
![](https://cdn.nlark.com/yuque/__puml/0e18e4591a157050e487a7c426d67f50.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcbmNsYXNzIFNpbmdsZXRvbiB7XG4gIC0gc3RhdGljIHZvbGF0aWxlIGluc3RhbmNlID0gbnVsbFxuICAtIGNvbnN0cnVjdG9yOiBTaW5nbGV0b25cbiAgKyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogc3luY2hyb25pemVkIFNpbmdsZXRvblxuICArIG9wZXJhdGlvbigpOiB2b2lkXG59XG5ub3RlIGxlZnQgb2YgU2luZ2xldG9uOjpnZXRJbnN0YW5jZVxuLy8g5LiA6YeN5qOA5rWLXG5pZiAoaW5zdGFuY2UgPT0gbnVsbCl7XG5cdFx0c3luY2hyb25pemVkKC4uKSB7XG4vL1x05LqM6YeN5qOA5rWLXG5cdFx0XHRcdGlmKGluc3RhbmNlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0aW5zdGFuY2UgPSBjb25zdHJ1Y3QoKTtcblx0XHRcdFx0fVxuXHRcdH1cbn1cbnJldHVybiBpbnN0YW5jZTtcbmVuZCBub3RlXG5TaW5nbGV0b24gLS0-IFNpbmdsZXRvbiA6IGdldEluc3RhbmNlKClcbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzBlMThlNDU5MWExNTcwNTBlNDg3YTdjNDI2ZDY3ZjUwLnN2ZyIsImlkIjoiem9KdWciLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)### 代码实现
#### 饿汉
```java
public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();

    // 私有构造方法，防止外部实例化
    private EagerSingleton() {
    }

    // 获取单例对象的静态方法
    public static EagerSingleton getInstance() {
        return instance;
    }
}
```
`EagerSingleton` 类的构造方法被声明为私有，以防止外部通过 `new` 关键字实例化该类。而类中定义了一个私有静态变量 `instance`，它在类加载的时候就被创建并初始化为 `EagerSingleton` 类的一个实例。
`getInstance()` 方法是获取单例对象的静态方法，它直接返回了已经创建好的 `instance` 对象。
由于饿汉单例在类加载的时候就创建了对象，因此它具有线程安全的特性，但可能会造成一定的资源浪费，因为无论是否使用该单例对象，都会被提前创建。

#### 懒汉单锁
```java
public class LazySingleton {
    private static LazySingleton instance;

    // 私有构造方法，防止外部实例化
    private LazySingleton() {
    }

    // 获取单例对象的静态方法，使用synchronized关键字实现线程安全
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```
#### 懒汉双重检测
```java
public class LazySingleton {
    private static volatile LazySingleton instance;

    // 私有构造方法，防止外部实例化
    private LazySingleton() {
    }

    // 获取单例对象的静态方法，使用双重检测实现延迟加载和线程安全
    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```
在上面的代码中，`LazySingleton` 类的构造方法被声明为私有，以防止外部通过 `new` 关键字实例化该类。类中定义了一个私有静态变量 `instance`，它在第一次调用 `getInstance()` 方法时才会被创建并初始化为 `LazySingleton` 类的一个实例。
`getInstance()` 方法是获取单例对象的静态方法。在方法中，首先检查 `instance` 是否为空，如果为空则进入同步代码块。在同步代码块内部，再次检查 `instance` 是否为空，这是为了防止多个线程同时通过了第一个检查而进入同步块，从而创建多个实例。如果 `instance` 仍然为空，则创建新的实例并将其赋值给 `instance`。
使用 `volatile` 关键字修饰 `instance` 变量可以保证变量的可见性，从而避免在多线程环境下出现问题。
懒汉双重检测通过双重检查和同步块的方式实现了延迟加载和线程安全，同时也提高了性能。因此，它是一种常见的单例模式实现方式。

---

> 饿汉式单例类不能实现延迟加载，不管将来用不用，它始终占据内存；
> 懒汉式单例类线程安全控制烦琐，而且性能受影响。
> 可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题。
> 有没有一种方法，能够将两种单例的缺点都克服，而将两者的优点合二为一呢？答案是肯定的。下面来学习这种更好的被称为 `Initialization on Demand Holder（IoDH）` 的技术。实现 `IoDH` 时，需在单例类中增加一个静态 `（static）` 内部类，在该内部类中创建单例对象，再将该单例对象通过 `getInstance()` 方法返回给外部使用

#### `IODH`实现懒汉模式
```java
public class LazySingleton {
    private static class SingletonHolder {
        private static final LazySingleton instance = new LazySingleton();
    }

    // 私有构造方法，防止外部实例化
    private LazySingleton() {
    }

    // 获取单例对象的静态方法
    public static LazySingleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

在上面的代码中，`LazySingleton` 类内部定义了一个私有静态内部类 `SingletonHolder`。在 `SingletonHolder` 内部，定义了一个私有静态变量 `instance`，它是 `LazySingleton` 类的一个实例。
由于静态内部类 `SingletonHolder` 只有在 `getInstance()` 方法被调用时才会被加载，所以在类加载的过程中并不会创建 `instance` 对象。只有当第一次调用 `getInstance()` 方法时，`SingletonHolder` 类会被加载，从而创建并初始化 `instance` 对象。这种方式利用了 `Java` 类加载的线程安全性和延迟加载的特性，实现了懒汉模式。
因此，通过 `IODH` 实现懒汉模式，可以在需要时延迟创建单例对象，并且保证了线程安全性。

###  单例模式总结
单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。
#### 主要优点单例模式的主要优点如下：
（1）单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。
（2）由于在系统内存中只存在一个对象，因此可以节约系统资源。对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。（3）允许可变数目的实例。基于单例模式，开发人员可以进行扩展，使用与控制单例对象相似的方法来获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题。（注：自行提供指定数目实例对象的类可称之为多例类。）

#### 单例模式的主要缺点如下：
（1）由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
（2）单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。
（3）现在很多面向对象语言（如Java、C＃）的运行环境都提供了自动垃圾回收技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。
### 适用场景：
（1）系统只需要一个实例对象。例如，系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。
（2）客户调用类的单个实例只允许使用一个公共访问点。除了该公共访问点，不能通过其他途径访问该实例。


## 集中式工厂的实现～简单工厂模式
> 简单工厂模式（`Simple Factory Pattern`）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（`static`）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。
> 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

![](https://cdn.nlark.com/yuque/__puml/b912dfd4f33e5ef5d4bb94b90fdf844d.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuXG5jbGFzcyBGYWN0b3J5IHtcbiAgKyB7c3RhdGljfSBmYWN0b3J5TWV0aG9kKCk6IFByb2R1Y3Rcbn1cbmFic3RyYWN0IGNsYXNzIFByb2R1Y3Qge1xuICArIHthYnN0cmFjdH0gb3BlcmF0aW9uKCk6IHZvaWRcbn1cbmNsYXNzIENvbmNyZXRlUHJvZHVjdEEgZXh0ZW5kcyBQcm9kdWN0IHtcbiAgKyBvcGVyYXRpb24oKTogdm9pZFxufVxuY2xhc3MgQ29uY3JldGVQcm9kdWN0QiBleHRlbmRzIFByb2R1Y3Qge1xuICArIG9wZXJhdGlvbigpOiB2b2lkXG59XG5cbkZhY3RvcnkgLXVwLT4gQ29uY3JldGVQcm9kdWN0QSA6IGNyZWF0ZXMgPlxuRmFjdG9yeSAtdXAtPiBDb25jcmV0ZVByb2R1Y3RCIDogY3JlYXRlcyA-XG5AZW5kdW1sIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC9iOTEyZGZkNGYzM2U1ZWY1ZDRiYjk0YjkwZmRmODQ0ZC5zdmciLCJpZCI6IlhzQURwIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==)在简单工厂模式结构图中包含以下3个角色。
（1）`Factory`（工厂角色）：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。在工厂类中提供了静态的工厂方法factoryMethod（），它的返回类型为抽象产品类型Product。
（2）`Product`（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法。抽象产品的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。
（3）`ConcreteProduct`（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。
### 代码实现
```java
package create;


// 抽象产品角色
abstract class Product {
    abstract void  operation();
}

// 具体产品角色A
class ConcreteProductA extends Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA operation");
    }
}

// 具体产品角色B
class ConcreteProductB extends Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB operation");
    }
}

// 工厂类
class Factory {
    public static Product factoryMethod(String productType) {
        Product product = null;
        if (productType.equals("A")) {
            product = new ConcreteProductA();
        } else if (productType.equals("B")) {
            product = new ConcreteProductB();
        }
        return product;
    }
}

// 客户端代码

public class SimpleFactory {
    public static void main(String[] args) {
        // 创建具体产品A
        Product productA = Factory.factoryMethod("A");
        productA.operation();

        // 创建具体产品B
        Product productB = Factory.factoryMethod("B");
        productB.operation();
    }
}

```

### 简单工厂模式总结
简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。
#### 主要优点简单工厂模式的主要优点如下：
（1）工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品。
简单工厂模式实现了对象创建和使用的分离。
（2）客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。
对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。
（3）通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

#### 简单工厂模式的主要缺点如下：
（1）由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。
（2）使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。
（3）系统扩展困难。一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。（4）简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 适用场景：
在以下情况下可以考虑使用简单工厂模式：
（1）工厂类负责创建的对象比较少。由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
（2）客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

## 多态工厂的实现～工厂方法模式
> 工厂方法模式（`Factory Method Pattern`）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。
> 工厂方法模式又简称为工厂模式（`Factory Pattern`），又可称作虚拟构造器模式（`Virtual Constructor Pattern`）或多态工厂模式（`Polymorphic Factory Pattern`）。
> 工厂方法模式是一种类创建型模式。


![](https://cdn.nlark.com/yuque/__puml/314d80b081e701c799d115b626d17b3b.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuaW50ZXJmYWNlIEZhY3Rvcnkge1xuXHQrIGZhY3RvcnlNZXRob2QoKTpQcm9kdWN0XG59XG5cbm5vdGUgbGVmdCBvZiBGYWN0b3J5OjpcImZhY3RvcnlNZXRob2QoKTpQcm9kdWN0XCJcblx0Li4uIOWFtuS7lumAu-i-kVxuXHRyZXR1cm4gbmV3IFByb2R1Y3QoKTtcbmVuZCBub3RlXG5hYnN0cmFjdCBjbGFzcyBQcm9kdWN0IHtcbn1cblxuY2xhc3MgU3ViUHJvZHVjdDEgZXh0ZW5kcyBQcm9kdWN0IGltcGxlbWVudHMgRmFjdG9yeXtcblx0KyBmYWN0b3J5TWV0aG9kKCk6UHJvZHVjdFxufVxuXG5tYWluIC11cC0-IEZhY3Rvcnk6IOiwg-eUqOW3peWOguaWueazlVxuXG5AZW5kdW1sIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC8zMTRkODBiMDgxZTcwMWM3OTlkMTE1YjYyNmQxN2IzYi5zdmciLCJpZCI6ImRCdFQxIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==)工厂方法模式结构图中包含以下4个角色。
（1）`Product`（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
（2）`ConcreteProduct`（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
（3）`Factory`（抽象工厂）：在抽象工厂类中，**声明了工厂方法（Factory Method）**，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
（4）`ConcreteFactory`（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

### 代码实现
```java
package create;


public class FactoryMethod {
    
    public static void main(String[] args) throws Exception{
//        Factory factory = new ConcreteFactory();
//        Factory factory = (Factory)Class.forName("create.FactoryMethod$ConcreteFactory").newInstance();
        // 通过配置的方式传类名的引用使用反射创建对象，方便后面扩展
        Factory factory = (Factory)Class.forName("create.FactoryMethod$ConcreteFactory")
            .getDeclaredConstructor()
            .newInstance();

        Product product = factory.factoryMethod();
        System.out.println(product.name);
    }

    static class Product {
        String name;

        Product(String name) {
            this.name = name;
        }
    }


    interface Factory {
         Product factoryMethod();
    }

    static class ConcreteFactory  implements Factory {
        @Override
        public Product factoryMethod() {
            return new Product("具体产品1");
        }
    }
}

```
### 工厂方法总结
> 工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题。

#### 工厂方法模式的主要优点如下：
（1）在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节。用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
（2）基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。
（3）使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合开闭原则。
#### 工厂方法模式的主要缺点如下：
（1）在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
（2）由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
### 适用场景
在以下情况下可以考虑使用工厂方法模式：
（1）客户端不知道其所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。
（2）抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。

## 产品族的创建～抽象工厂模式
> 工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题。但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是本章将要学习的抽象工厂模式的基本思想。

> 为了更好地理解抽象工厂模式，这里先引入如下两个概念：
> （1）产品等级结构。产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
> （2）产品族。在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。
> ![image.png](https://cdn.nlark.com/yuque/0/2024/png/21883277/1705767210833-aef44de0-c7e8-426a-901b-e5b3832e705f.png#averageHue=%23f3f3f3&clientId=u9616b4c4-f126-4&from=paste&height=297&id=ud6591071&originHeight=594&originWidth=1260&originalType=binary&ratio=2&rotation=0&showTitle=false&size=195187&status=done&style=none&taskId=u2c392bca-75fa-4048-8036-cfa4f0ac12e&title=&width=630)

> 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。
> **抽象工厂模式定义如下**：抽象工厂模式（`Abstract Factory Pattern`）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。


![](https://cdn.nlark.com/yuque/__puml/6cd45c84db600be1ab78165fbee58a02.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYWJzdHJhY3QgY2xhc3Mg5oq96LGh5Lqn5ZOB5pePMea1t-WwlHt9XG5cbmNsYXNzIOS6p-WTgTHnlLXop4bmnLogZXh0ZW5kcyDmir3osaHkuqflk4Hml48x5rW35bCUIHt9XG5jbGFzcyDkuqflk4Ey5rSX6KGj5py6IGV4dGVuZHMg5oq96LGh5Lqn5ZOB5pePMea1t-WwlCB7fVxuXG5hYnN0cmFjdCBjbGFzcyDmir3osaHkuqflk4Hml48ye31cblxuYWJzdHJhY3QgY2xhc3Mg5oq96LGh5bel5Y6CIHtcblxuKyDnlJ_kuqfmir3osaHkuqflk4Hml48xKCk65oq96LGh5Lqn5ZOB5pePMea1t-WwlFxuKyDnlJ_kuqfmir3osaHkuqflk4Hml48yKCk65oq96LGh5Lqn5ZOB5pePMlxufVxuXG5jbGFzcyDlhbfkvZPlt6XljoIxIGV4dGVuZHMg5oq96LGh5Lqn5ZOB5pePMea1t-WwlCBpbXBsZW1lbnRzIOaKveixoeW3peWOgiB7XG4rIOeUn-S6p-S6p-WTgTEoKTrmir3osaHkuqflk4Hml48x5rW35bCUXG4rIOeUn-S6p-S6p-WTgTIoKTrmir3osaHkuqflk4Hml48x5rW35bCUXG59XG5cbuWFt-S9k-W3peWOgjEgLXVwLT4g5Lqn5ZOBMeeUteinhuaculxu5YW35L2T5bel5Y6CMSAtdXAtPiDkuqflk4Ey5rSX6KGj5py6XG5cbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzZjZDQ1Yzg0ZGI2MDBiZTFhYjc4MTY1ZmJlZTU4YTAyLnN2ZyIsImlkIjoiWkFsS04iLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)在抽象工厂模式结构图中包含以下4个角色。
（1）`AbstractFactory`（抽象工厂）：它声明了一组用于创建一族产品的方法，每个方法对应一种产品。
（2）`ConcreteFactory`（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每种产品都位于某个产品等级结构中。
（3）`AbstractProduct`（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
（4）`ConcreteProduct`（具体产品）：它定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明的业务方法。

### 代码实现
```java

public class AbstractFactoryDemo {
    // 抽象产品族1
    static abstract class AbstractProductFamily1 {}

    // 产品1
    static class Product1 extends AbstractProductFamily1 {}

    // 产品2
    static class Product2 extends AbstractProductFamily1 {}

    // 抽象产品族2
    static abstract class AbstractProductFamily2 {}

    // 抽象工厂
    interface AbstractFactory {
        AbstractProductFamily1 createProductFamily1();
        AbstractProductFamily2 createProductFamily2();
    }

    // 具体工厂1
    static class ConcreteFactory1 implements AbstractFactory {
        @Override
        public AbstractProductFamily1 createProductFamily1() {
            return new Product1();
        }

        @Override
        public AbstractProductFamily2 createProductFamily2() {
            // 在具体工厂1中创建抽象产品族2的实例
            return null; // 根据具体情况进行实现
        }
    }


    public static void main(String[] args) {
        // 创建具体工厂1的实例
        AbstractFactory factory = new ConcreteFactory1();

        // 使用具体工厂1创建抽象产品族1的实例
        AbstractProductFamily1 product1 = factory.createProductFamily1();
        AbstractProductFamily1 product2 = factory.createProductFamily1();
        System.out.println(product1);
        System.out.println(product2);

        // 使用具体工厂1创建抽象产品族2的实例
        AbstractProductFamily2 product3 = factory.createProductFamily2();
        System.out.println(product3);

    }

}

```
### 抽象工厂总结
#### 抽象工厂模式的主要优点如下：
（1）抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
（2）当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
（3）增加新的产品族很方便，无须修改已有系统，符合开闭原则。

#### 抽象工厂模式的主要缺点是：
增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。
### 适用场景
在以下情况下可以考虑使用抽象工厂模式：
（1）一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。
（2）系统中有多于一个的产品族，而每次只使用其中某一个产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。
（3）属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类 型。
（4）产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。


## 对象的克隆～原型模式

![](https://cdn.nlark.com/yuque/__puml/91adaef392d27b2fd4e9e94a8c39a725.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYWJzdHJhY3QgY2xhc3MgUHJvdG90eXBlIGltcGxlbWVudHMgQ2xvbmVhYmxlIHtcblxuLSBTdHJpbmcgbmFtZTtcblxuKyBjbG9uZSgpOiBQcm90b3R5cGU7XG5cbn1cblxuY2xhc3MgQ29uY3JldGVQcm90b3R5cGVBIGV4dGVuZHMgUHJvdG90eXBlIHtcblx0KyBjbG9uZSgpOiBQcm90b3R5cGU7XG59XG5cbmNsYXNzIENvbmNyZXRlUHJvdG90eXBlQiBleHRlbmRzIFByb3RvdHlwZSB7XG5cdCsgY2xvbmUoKTogUHJvdG90eXBlO1xufVxuXG5jbGFzcyBDbGllbnR7fVxuXG5DbGllbnQgLXVwLT4gQ29uY3JldGVQcm90b3R5cGVBXG5cbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzkxYWRhZWYzOTJkMjdiMmZkNGU5ZTk0YThjMzlhNzI1LnN2ZyIsImlkIjoiaFJ2NFYiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)
在原型模式结构图中包含以下3个角色。
（1）`Prototype`（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。
（2）`ConcretePrototype`（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。
（3）`Client`（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。

### 代码简单实现
```java
package create;

public class PrototypeTest {

    public static void main(String[] args)  {
        Prototype prototype = new Prototype();
        prototype.setName("hello");
        System.out.println(prototype);
        Prototype clone = prototype.clone();
        System.out.println(clone);
        System.out.println(prototype.getName());
        System.out.println(clone.getName());
    }

}

// 原型类
class Prototype implements Cloneable {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Prototype clone(){
        try {
            return ((Prototype) super.clone());
        } catch (CloneNotSupportedException ignored) {
            System.out.println("当前对象不支持拷贝");
        }
        return null;
    }
}

```

### 原型模式总结
> 注意深浅拷贝

#### 原型模式的主要优点如下：
（1）当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
（2）扩展性较好。由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对原有系统都没有任何影响。
（3）原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样。原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
（4）可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作。

#### 原型模式的主要缺点如下：
（1）需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部。当对已有的类进行改造时，需要修改源代码，违背了开闭原则。
（2）在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。

### 适用场景
在以下情况下可以考虑使用原型模式：
（1）创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源）。新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。
（2）如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。
（3）需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态。通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。

## 复杂对象的组装与创建——建造者模式
建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
建造者模式是一种对象创建型模式。建造者模式一步一步地创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
![](https://cdn.nlark.com/yuque/__puml/5586e5bd4cf5fa8bda2a4a57f2b78182.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuY2xhc3MgUHJvZHVjdCB7XG5cdC0gcGFydEFcblx0LSBwYXJ0QlxuXHQtIHBhcnRDXG5cbn1cblxuYWJzdHJhY3QgY2xhc3MgQnVpbGRlciB7XG5cdCsgYnVpbGRQYXJ0QSgpXG5cdCsgYnVpbGRQYXJ0QigpXG5cdCsgYnVpbGRQYXJ0QygpXG5cdCsgZ2V0UmVzdWx0KCk6IFByb2R1Y3Rcbn1cblxuY2xhc3MgRGlyZWN0b3Ige1xuLSBidWlsZGVyXG4rIGNvbnN0cnVjdCgpXG59XG5ub3RlIGxlZnQgb2YgRGlyZWN0b3I6OlwiY29uc3RydWN0KClcIlxuXHRidWlsZGVyLmJ1aWxkUGFydEEoKTtcblx0YnVpbGRlci5idWlsZFBhcnRCKCk7XG5cdGJ1aWxkZXIuYnVpbGRQYXJ0QygpXG5cdHJldHVybiBidWlsZGVyLmdldFJlc3VsdCgpO1xuZW5kIG5vdGVcblxuRGlyZWN0b3IgKi0-IEJ1aWxkZXI6IOaMh-aMpeiAhei3n2J1aWxkZXLlsZ7kuo7nu4TlkIjlhbPns7tcblxuY2xhc3MgY29uY3JldGVCdWlsZGVyIGV4dGVuZHMgQnVpbGRlciB7XG5cdCsgYnVpbGRQYXJ0QSgpXG5cdCsgYnVpbGRQYXJ0QigpXG5cdCsgYnVpbGRQYXJ0QygpXG5cdCsgZ2V0UmVzdWx0KCk6IFByb2R1Y3Rcbn1cblxuY29uY3JldGVCdWlsZGVyIC5sZWZ0Li4-IFByb2R1Y3QgOiDlhbfkvZPlu7rpgKDogIXnlJ_kuqflr7nosaFcblxuXG5cbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzU1ODZlNWJkNGNmNWZhOGJkYTJhNGE1N2YyYjc4MTgyLnN2ZyIsImlkIjoiSWZpZnoiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)
在建造者模式结构中包含以下4个角色。
（1）Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口。在该接口中一般声明两类方法：一类方法是 `buildPartX（）`，用于创建复杂对象的各个部件；另一类方法是 `getResult（）`，用于返回复杂对象。Builder既可以是抽象类，也可以是接口。
（2）ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确其所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
（3）Product（产品角色）：它是被构建的复杂对象，包含多个组成部件。具体建造者创建该产品的内部表示并定义其装配过程。
（4）Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序。指挥者与抽象建造者之间存在关联关系，可以在其 `construct（）` 建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。

### 代码简单实现
```java
package create;

// 使用示例
public class BuilderDemo {
    public static void main(String[] args) {
        Car car = new CarBuilder()
            .setBrand("Toyota")
            .setModel("Camry")
            .setYear(2022)
            .setHorsepower(203)
            .build();

        System.out.println(car);
    }
}

// 产品类
class Car {
    private final String brand;
    private final String model;
    private final int year;
    private final int horsepower;

    public Car(String brand, String model, int year, int horsepower) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.horsepower = horsepower;
    }

    // Getters
    // ...

    @Override
    public String toString() {
        return "Car [brand=" + brand + ", model=" + model + ", year=" + year + ", horsepower=" + horsepower + "]";
    }
}

// 建造者类
class CarBuilder {
    private String brand;
    private String model;
    private Integer year;
    private Integer horsepower;

    public CarBuilder setBrand(String brand) {
        this.brand = brand;
        return this;
    }

    public CarBuilder setModel(String model) {
        this.model = model;
        return this;
    }

    public CarBuilder setYear(int year) {
        this.year = year;
        return this;
    }

    public CarBuilder setHorsepower(int horsepower) {
        this.horsepower = horsepower;
        return this;
    }

    public Car build() {
        if (brand == null || model == null || year == null || horsepower == null) {
            throw new RuntimeException("没有完全建造产品");
        }
        return new Car(brand, model, year, horsepower);
    }
}

```

### 建造者模式总结
#### 建造者模式的主要优点如下：
（1）在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
（2）每个具体建造者都相对独立，而与其他具体建造者无关。因此，可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合开闭原则。
（3）可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

#### 建造者模式的主要缺点如下：
（1）建造者模式所创建的产品一般具有较多的共同点，其组成部分相似。如果产品之间的差异性很大，例如很多组成部分都不相同，就不适合使用建造者模式，因此其使用范围受到一定的限制。
（2）如果产品的内部结构复杂且多变，可能会需要定义很多具体建造者类来实现这种变化，这就导致系统变得很庞大，增加系统的理解难度和运行成本。
### 适用场景
在以下情况下可以考虑使用建造者模式：
（1）需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。
（2）需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
（3）对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。
（4）隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

# 组合的艺术～结构型模式
> 结构型模式（Structural Pattern）关注如何将现有类或对象组织在一起形成更加强大的结构。不同的结构型模式从不同的角度来组合类或对象，在尽可能满足各种面向对象设计原则的同时，为类或对象的组合提供一系列巧妙的解决方案。


> 在几乎所有的软件中都能够找到外观模式的应用，例如，绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏。在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们，用户可以快速访问子系统，降低了系统的复杂程度。此外，所有涉及与多个业务对象交互的场景都可以考虑使用外观模式进行重构，例如Java EE中的Session外观模式。

##  提供统一入口——外观模式
在软件开发中，有时候为了完成一项较为复杂的功能，一个类需要和多个其他业务类交互，而这些需要交互的业务类经常会作为一个完整的整体出现，由于涉及的类比较多，导致使用时代码较为复杂。此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而使用这些业务类的类只需和该类交互即可。外观模式通过引入一个新的外观类来实现该功能。外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。外观模式也称门面模式。

![](https://cdn.nlark.com/yuque/__puml/1aecc656b4e5975c5c64c401e6dbde2c.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcbmNsYXNzIENsaWVudCB7fVxuXG5jbGFzcyBGYWNhZGUge31cblxuY2xhc3MgU3ViU3lzdGVtQSB7fVxuXG5jbGFzcyBTdWJTeXN0ZW1CIHt9XG5cbmNsYXNzIFN1YlN5c3RlbUMge31cblxuQ2xpZW50IC5kb3duLj4gRmFjYWRlOiDlrqLmiLfnq6_pgJrov4dmYWNhZGXnu5_kuIDosIPnlKjlrZDns7vnu59cbkZhY2FkZSAuLj5TdWJTeXN0ZW1BXG5GYWNhZGUgLi4-IFN1YlN5c3RlbUJcbkZhY2FkZSAuLj4gU3ViU3lzdGVtQ1xuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvMWFlY2M2NTZiNGU1OTc1YzVjNjRjNDAxZTZkYmRlMmMuc3ZnIiwiaWQiOiJtSnNTayIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=)在外观模式结构图中包含以下两个角色。
（1）`Facade`（外观角色）：在客户端可以调用这个角色的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任。在正常情况下，它将所有从客户端发来的请求委派到相应的子系统中去，传递给相应的子系统对象处理。
（2）`SubSystem`（子系统角色）：在软件系统中可以有一个或者多个子系统角色。每个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。每个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求。**子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。**

> 外观模式的主要目的在于降低系统的复杂程度。在面向对象软件系统中，类与类之间的关系越多，并不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化。而外观模式的引入很大程度上降低了类之间的通信和关系。
> 引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户端类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。


### 简单代码实现
```java
package struct;

public class FacadeDemo {

    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.operate();

    }

    static class Facade {
        private SubSystemA subSystemA;
        private SubSystemB subSystemB;
        private SubSystemC subSystemC;
        public Facade() {
            // 可以抽到配置文件中进行配置
            subSystemA = new SubSystemA();
            subSystemB = new SubSystemB();
            subSystemC = new SubSystemC();
        }

        public void operate() {
            subSystemA.hello();
            subSystemB.hello();
            subSystemC.hello();
        }

    }

    static class SubSystemA {
        private void hello() {
            System.out.println(">>>> hello A");
        }

    }
    static class SubSystemB {
        private void hello() {
            System.out.println(">>>> hello B");
        }

    }
    static class SubSystemC {
        private void hello() {
            System.out.println(">>>> hello C");
        }

    }
}

```

### 外观模式总结
#### 外观模式的主要优点如下：
（1）对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。
（2）实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。
（3）一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
（4）只是提供了一个访问子系统的统一入口，并不影响客户端直接使用子系统类。

#### 外观模式的主要缺点如下：
（1）不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。（2）如果设计不当，增加新的子系统可能需要修改外观类的源代码，这违背了开闭原则。
### 适用场景
在以下情况下可以考虑使用外观模式：
（1）当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。
（2）客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。
（3）在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

### 补充说明
在实际应用中具体使用外观模式时，可以参考以下3条关于外观角色设计的补充说明。
（1）在很多情况下为了节约系统资源，系统中只需要一个外观类的实例。换言之，外观类可以是一个单例类。因此可以通过单例模式来设计外观类，从而确保系统中只有唯一一个访问子系统的入口，并降低对系统资源的消耗。引入单例模式的外观模式结构如图所示。当然，能够设计为单例类的外观类一定是具体外观类，而不是抽象外观类。
![](https://cdn.nlark.com/yuque/__puml/4cffc2da46f124d0d63417a50936158e.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcbmNsYXNzIENsaWVudCB7fVxuXG5jbGFzcyBGYWNhZGUge1xuLSBpbnN0YW5jZTogRmFjYWRlXG4tIEZhY2FkZSgpIDog56eB5pyJ5YyW5p6E6YCg5Ye95pWw6YG_5YWN5aSW6YOo6LCD55SoXG4rIGdldEluc3RhbmNlKCk6IEZhY2FkZVxufVxuXG5cbmNsYXNzIFN1YlN5c3RlbUEge31cblxuY2xhc3MgU3ViU3lzdGVtQiB7fVxuXG5jbGFzcyBTdWJTeXN0ZW1DIHt9XG5cbkNsaWVudCAuZG93bi4-IEZhY2FkZTog5a6i5oi356uv6YCa6L-HZmFjYWRl57uf5LiA6LCD55So5a2Q57O757ufXG5GYWNhZGUgLi4-U3ViU3lzdGVtQVxuRmFjYWRlIC4uPiBTdWJTeXN0ZW1CXG5GYWNhZGUgLi4-IFN1YlN5c3RlbUNcbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzRjZmZjMmRhNDZmMTI0ZDBkNjM0MTdhNTA5MzYxNThlLnN2ZyIsImlkIjoidEd2RDEiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)（2）在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向客户端提供相应的业务功能。
（3）试图通过外观类为子系统增加新行为的做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新行为。新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。

### 抽象外观类的引入
在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则。因此，可以通过引入抽象外观类来对系统进行改进，在一定程度上解决该问题。
在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类。由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。
![](https://cdn.nlark.com/yuque/__puml/54207e8f37cda56ea7674ffa670817e4.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcbmNsYXNzIENsaWVudCB7fVxuXG5hYnN0cmFjdCBjbGFzcyBBYnN0cmFjdEZhY2FkZSB7fVxuY2xhc3MgRmFjYWRlIGV4dGVuZHMgQWJzdHJhY3RGYWNhZGV7fVxuXG5jbGFzcyBOZXdGYWNhZGUgZXh0ZW5kcyBBYnN0cmFjdEZhY2FkZSB7fVxuY2xhc3MgU3ViU3lzdGVtQSB7fVxuXG5jbGFzcyBTdWJTeXN0ZW1CIHt9XG5cbmNsYXNzIFN1YlN5c3RlbUMge31cblxuY2xhc3MgTmV3U3ViU3lzdGVtQXt9XG5cbkNsaWVudCAuZG93bi4-IEZhY2FkZTog6YCa6L-H6YWN572u5paH5Lu25Yaz5a6a6LCD55So5ZOq5Liq5YW35L2TRmFjYWRlXG5GYWNhZGUgLi4-U3ViU3lzdGVtQVxuRmFjYWRlIC4uPiBTdWJTeXN0ZW1CXG5GYWNhZGUgLi4-IFN1YlN5c3RlbUNcbkNsaWVudCAuLj4gTmV3RmFjYWRlXG5OZXdGYWNhZGUgLi4-IE5ld1N1YlN5c3RlbUFcblxuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvNTQyMDdlOGYzN2NkYTU2ZWE3Njc0ZmZhNjcwODE3ZTQuc3ZnIiwiaWQiOiJFNVdGTyIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=)
## 扩展系统功能——装饰模式
装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。在现实生活中，这种情况也到处存在。例如一张照片，可以不改变照片本身，给它增加一个相框，使得它具有防潮的功能，而且用户可以根据需要给它增加不同类型的相框，甚至可以在一个小相框的外面再套一个大相框。
装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。
>  装饰模式定义如下：
> 装饰模式（`Decorator Pattern`）：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。

![](https://cdn.nlark.com/yuque/__puml/598917e6c2159800c23dc1113903c5f3.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuaW50ZXJmYWNlIENvbXBvbmVudCB7XG5cdCsgdm9pZCBkaXNwbGF5KClcbn0gXG5cbmFic3RyYWN0IGNsYXNzIERlY29yYXRvciBpbXBsZW1lbnRzIENvbXBvbmVudCB7XG4tIENvbXBvbmVudCBjb21wb25lbnQ7XG4rIERlY29yYXRvcihDb21wb25lbnQgY29tcG9uZW50KTtcbisgdm9pZCBkaXNwbGF5KClcbn0gXG5cbmNsYXNzIENvbXBvbmVudEEgaW1wbGVtZW50cyBDb21wb25lbnQge1xuKyB2b2lkIGRpc3BsYXkoKVxufVxuY2xhc3MgQ29tcG9uZW50QiBpbXBsZW1lbnRzIENvbXBvbmVudCB7XG4rIHZvaWQgZGlzcGxheSgpXG59XG5cbmNsYXNzIERlY29yYXRvckEgZXh0ZW5kcyBEZWNvcmF0b3Ige1xuKyBEZWNvcmF0b3JBKENvbXBvbmV0IGNvbXBvbmVudClcbisgZGlzcGxheSgpOnZvaWRcbi0gYWRkQmVoYXZpb3IoKTp2b2lkXG59XG5ub3RlIGxlZnQgb2YgRGVjb3JhdG9yQTo6ZGlzcGxheVxuc3VwZXIuZGlzcGxheSgpO1xuYWRkQmVoYXZpb3IoKTtcbmVuZCBub3RlXG5cbmNsYXNzIENsaWVudHt9XG5cbkNsaWVudCAtZG93bi0-IENvbXBvbmVudDog6LCD55So57uE5Lu2XG5cblxuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvNTk4OTE3ZTZjMjE1OTgwMGMyM2RjMTExMzkwM2M1ZjMuc3ZnIiwiaWQiOiJkTUxVYyIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=)在装饰模式结构图中包含以下4个角色。
（1）Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法。它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。
（2）ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
（3）Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。
（4）ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。

### 简单代码实现
```java
package struct;

public class DecoratorDemo {

    public static void main(String[] args) {
        Component component = new DecoratorA(new ComponentA());
        component.display();

        Component component1 = new DecoratorA(new ComponentB());
        component1.display();
    }


    interface Component {
        void display();
    }

    abstract static class Decorator implements Component {
        private final Component component;

        public Decorator(Component component) {
            this.component = component;
        }

        @Override
        public void display() {
            System.out.println(">>>>>装饰器抽象类");
            component.display();
        }
    }

    static class ComponentA implements Component {
        @Override
        public void display() {
            System.out.println(">>>>>我是组件A");
        }
    }

    static class ComponentB implements Component {
        @Override
        public void display() {
            System.out.println(">>>>>> 我是组件B");
        }
    }

    static class DecoratorA extends Decorator {
        public DecoratorA(Component component) {
            super(component);
        }

        @Override
        public void display() {
            super.display();
            addBehavior();

        }

        private void addBehavior() {
            System.out.println(">>>>> 我是DecoratorA额外添加的");
        }
    }


}

```
运行结果：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21883277/1706347865437-cdbccb5d-9e9c-44d1-9b15-447261126cd2.png#averageHue=%2327282b&clientId=u9f51ca74-7f9b-4&from=paste&height=150&id=u318b6adc&originHeight=300&originWidth=806&originalType=binary&ratio=2&rotation=0&showTitle=false&size=51253&status=done&style=none&taskId=uca36fc0f-ba3c-46a6-8be1-b0026675e7b&title=&width=403)
### 透明和半透明
在实际使用过程中，由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，称为半透明（Semi-transparent）装饰模式。而标准的装饰模式是透明（Transparent）装饰模式。下面对这两种装饰模式进行较为详细的介绍。
#### 透明模式
在透明装饰模式中，要求客户端完全针对抽象编程。装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。也就是应该使用如下代码：
```java
Component c，c1;       //使用抽象构件类型定义对象
c = new ConcreteComponent();
c1 = new ConcreteDecorator (c);
```
而不应该使用如下代码：
```java
ConcreteComponent c;    //使用具体构件类型定义对象
c = new ConcreteComponent();

// 或者
ConcreteDecorator c1;  //使用具体装饰类型定义对象
c1 = new ConcreteDecorator(c);
```
透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别。
此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象。
在实现透明装饰模式时，要求具体装饰类的操作方法(即上文 `uml` 中的 `display()`)覆盖抽象装饰类的操作方法，除了调用原有对象的操作方法外还需要调用新增的 `addedBehavior（）` 方法来增加新行为。
#### 半透明装饰模式
透明装饰模式的设计难度较大，而且有时用户需要单独调用新增的业务方法。为了能够调用到新增方法，不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。
### 装饰模式注意事项
（1）尽量保持装饰类的接口与被装饰类的接口相同。这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。也就是说，在可能的情况下，应该尽量使用透明装饰模式。
（2）尽量保持具体构件类ConcreteComponent是一个“轻”类。也就是说，不要把太多的行为放在具体构件类中，可以通过装饰类对其进行扩展。
（3）如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。
![](https://cdn.nlark.com/yuque/__puml/6f3b6ea300886caac6e7ea62342a4fab.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuXG5jbGFzcyBDb21wb25lbnRBICB7XG4rIGRpc3BsYXkoKTp2b2lkXG59XG5cbmFic3RyYWN0IGNsYXNzIERlY29yYXRvciBleHRlbmRzIENvbXBvbmVudEEge1xuKyBkaXNwbGF5KCk6dm9pZFxufSBcblxuXG5cbmNsYXNzIERlY29yYXRvckEgZXh0ZW5kcyBEZWNvcmF0b3Ige1xuKyBkaXNwbGF5KCk6dm9pZFxuLSBhZGRCZWhhdmlvcigpOnZvaWRcbn1cbm5vdGUgbGVmdCBvZiBEZWNvcmF0b3JBOjpkaXNwbGF5XG5zdXBlci5kaXNwbGF5KCk7XG5hZGRCZWhhdmlvcigpO1xuZW5kIG5vdGVcblxuY2xhc3MgRGVjb3JhdG9yQiBleHRlbmRzIERlY29yYXRvcnt9XG5cbmNsYXNzIENsaWVudHt9XG5cbkNsaWVudCAtZG93bi0-IENvbXBvbmVudEE6IOiwg-eUqOe7hOS7tlxuXG5cbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzZmM2I2ZWEzMDA4ODZjYWFjNmU3ZWE2MjM0MmE0ZmFiLnN2ZyIsImlkIjoiRG03T3giLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9)### 装饰模式总结
装饰模式降低了系统的耦合度，可以动态地增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在Java IO中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。
#### 装饰模式的主要优点如下：
（1）对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。
（2）可以通过一种动态的方式来扩展一个对象的功能。通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。
（3）可以对一个对象进行多次装饰。通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。
（4）具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合开闭原则。
#### 装饰模式的主要缺点如下：
（1）使用装饰模式进行系统设计时将产生很多小对象。这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同。大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能。
（2）装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难。对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。
### 适用场景
适用场景在以下情况下可以考虑使用装饰模式：
（1）在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
（2）当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。
> 不能采用继承的情况主要有两类：
> 第1类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；
> 第2类是因为类已定义为不能被继承（如Java语言中的final类）。


## 树形结构的处理——组合模式
组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“部分—整体”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，又可以称为“部分—整体”（Part-Whole）模式，它是一种对象结构型模式。
在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。
![](https://cdn.nlark.com/yuque/__puml/902906e846a8c895bbf001fed57a40c0.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcbisgb3BlcmF0aW9uKClcbisgYWRkKENvbXBvbmVudCBjKVxuKyByZW1vdmUoQ29tcG9uZW50IGMpXG4rIGdldENoaWxkKGludCBpKVxufVxuXG5jbGFzcyBMZWFmIGV4dGVuZHMgQ29tcG9uZW50IHtcbisgb3BlcmF0aW9uKClcbisgYWRkKENvbXBvbmVudCBjKVxuKyByZW1vdmUoQ29tcG9uZW50IGMpXG4rIGdldENoaWxkKGludCBpKVxufVxuXG5jbGFzcyBDb21wb3NpdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuLSBMaXN0PENvbXBvbmVudD4gY2hpbGRcbisgb3BlcmF0aW9uKClcbisgYWRkKENvbXBvbmVudCBjKVxuKyByZW1vdmUoQ29tcG9uZW50IGMpXG4rIGdldENoaWxkKGludCBpKVxufVxuXG5ub3RlIGxlZnQgb2YgQ29tcG9zaXRlOjpvcGVyYXRpb25cbmZvciAoQ29tcG9uZW50IGMgOiBjaGlsZCkge1xuXHRjLm9wZXJhdGlvbigpXG59XG5cbmVuZCBub3RlXG5cbmNsYXNzIENsaWVudHt9XG5DbGllbnQgLi4-IENvbXBvbmVudFxuQ29tcG9zaXRlICotdXAtPiBDb21wb25lbnQ6IOe7hOWQiOWFs-ezu1xuXG5AZW5kdW1sIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC85MDI5MDZlODQ2YThjODk1YmJmMDAxZmVkNTdhNDBjMC5zdmciLCJpZCI6IlpOWmQyIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==)在组合模式结构图中包含以下3个角色。
（1）Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，例如增加子构件、删除子构件、获取子构件等。
（2）Leaf（叶子构件）：它在组合模式结构中表示叶子节点对象。叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过捕获异常等方式进行处理。
（3）Composite（容器构件）：它在组合模式结构中表示容器节点对象。容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点。它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。
> 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器。客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。

### 代码实现
```java
package struct;
import java.util.ArrayList;
import java.util.List;

public class CompositionDemo {
    static abstract class Component {
        public abstract void operation();
        public abstract void add(Component c);
        public abstract void remove(Component c);
        public abstract Component getChild(int i);
    }

    static class Leaf extends Component {
        private final String name;

        public Leaf(String name) {
            this.name = name;
        }
        @Override
        public void operation() {
            System.out.println(this.name + "Leaf operation");
        }

        @Override
        public void add(Component c) {
            // Leaf 类没有实现 add 方法
        }

        @Override
        public void remove(Component c) {
            // Leaf 类没有实现 remove 方法
        }

        @Override
        public Component getChild(int i) {
            // Leaf 类没有实现 getChild 方法
            return null;
        }
    }

    static class Composite extends Component {
        private final List<Component> child = new ArrayList<>();

        private final String name;
        public Composite(String name) {
            this.name = name;
        }

        @Override
        public void operation() {
            System.out.println(this.name + "Composite operation");
            for (Component c : child) {
                c.operation();
            }
        }

        @Override
        public void add(Component c) {
            child.add(c);
        }

        @Override
        public void remove(Component c) {
            child.remove(c);
        }

        @Override
        public Component getChild(int i) {
            return child.get(i);
        }
    }


    public static void main(String[] args) {
        Component leaf1 = new Leaf("节点1");
        Component leaf2 = new Leaf("节点2");

        Component composite1 = new Composite("组件1");
        composite1.add(leaf1);
        composite1.add(leaf2);

        Component leaf3 = new Leaf("节点3");

        Component composite2 = new Composite("组件2");
        composite2.add(leaf3);
        composite2.add(composite1);

        composite2.operation();
    }

}



```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21883277/1706429757172-4b95765a-4fe2-425e-a5a1-8708b36abb7f.png#averageHue=%232e2f33&clientId=u366fb3df-3d42-4&from=paste&height=111&id=ub75c762b&originHeight=222&originWidth=438&originalType=binary&ratio=2&rotation=0&showTitle=false&size=32876&status=done&style=none&taskId=u2980c02c-2af2-4db9-b624-61e7beab081&title=&width=219)

### 组合模式分为透明组合模式和安全组合模式两种形式
#### 透明组合模式
透明组合模式中，抽象构件 `Component` 中声明了所有用于管理成员对象的方法，包括 `add（）`、`remove（）` 以及 `getChild（）` 等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式。
透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 `add（）`、`remove（）` 以及 `getChild（）` 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。
![](https://cdn.nlark.com/yuque/__puml/902906e846a8c895bbf001fed57a40c0.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcbisgb3BlcmF0aW9uKClcbisgYWRkKENvbXBvbmVudCBjKVxuKyByZW1vdmUoQ29tcG9uZW50IGMpXG4rIGdldENoaWxkKGludCBpKVxufVxuXG5jbGFzcyBMZWFmIGV4dGVuZHMgQ29tcG9uZW50IHtcbisgb3BlcmF0aW9uKClcbisgYWRkKENvbXBvbmVudCBjKVxuKyByZW1vdmUoQ29tcG9uZW50IGMpXG4rIGdldENoaWxkKGludCBpKVxufVxuXG5jbGFzcyBDb21wb3NpdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuLSBMaXN0PENvbXBvbmVudD4gY2hpbGRcbisgb3BlcmF0aW9uKClcbisgYWRkKENvbXBvbmVudCBjKVxuKyByZW1vdmUoQ29tcG9uZW50IGMpXG4rIGdldENoaWxkKGludCBpKVxufVxuXG5ub3RlIGxlZnQgb2YgQ29tcG9zaXRlOjpvcGVyYXRpb25cbmZvciAoQ29tcG9uZW50IGMgOiBjaGlsZCkge1xuXHRjLm9wZXJhdGlvbigpXG59XG5cbmVuZCBub3RlXG5cbmNsYXNzIENsaWVudHt9XG5DbGllbnQgLi4-IENvbXBvbmVudFxuQ29tcG9zaXRlICotdXAtPiBDb21wb25lbnQ6IOe7hOWQiOWFs-ezu1xuXG5AZW5kdW1sIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC85MDI5MDZlODQ2YThjODk1YmJmMDAxZmVkNTdhNDBjMC5zdmciLCJpZCI6ImdTeG0wIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==)
#### 安全组合模式
安全组合模式中，在抽象构件 `Component` 中没有声明任何用于管理成员对象的方法，而是在 `Composite` 类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。
安全组合模式的缺点是不够透明。因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。
### 组合模式总结
#### 组合模式的主要优点如下：
（1）组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次。它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
（2）客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
（3）在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。
（4）组合模式为树形结构的面向对象实现提供了一种灵活的解决方案。通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。
#### 组合模式的主要缺点是：
在增加新构件时很难对容器中的构件类型进行限制。有时希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件。使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自相同的抽象层。在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。

### 适用场景
在以下情况下可以考虑使用组合模式：
（1）在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性地对待它们。
（2）在一个使用面向对象语言开发的系统中需要处理一个树形结构。
（3）在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，将来需要增加一些新的类型。

## 对象的间接访问——代理模式
代理模式定义如下：代理模式（Proxy Pattern）：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式是一种对象结构型模式。代理模式的结构比较简单，其核心是代理类。为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层。
![](https://cdn.nlark.com/yuque/__puml/5732101d5dd143aad23b665c0ee4470e.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuY2xhc3MgQ2xpZW50e31cblxuaW50ZXJmYWNlIFN1YmplY3Qge1xuKyByZXF1ZXN0KClcbn1cblxuY2xhc3MgUHJveHkgaW1wbGVtZW50cyBTdWJqZWN0IHtcbi0gUmVhbHJlcXVlc3Rcbi0gcHJlUmVxdWVzdCgpXG4rIHJlcXVlc3QoKVxuLSBwb3N0UmVxdWVzdCgpXG59XG5cbmNsYXNzIFJlYWxTdWJqZWN0IGltcGxlbWVudHMgU3ViamVjdCB7XG4rIHJlcXVlc3QoKVxufVxuQ2xpZW50IC0tPiBTdWJqZWN0XG5cblByb3h5IC1yaWdodC0-IFJlYWxTdWJqZWN0OiDku6PnkIblr7nosaHosIPnlKjnnJ_lrp7lr7nosaFcblxuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvNTczMjEwMWQ1ZGQxNDNhYWQyM2I2NjVjMGVlNDQ3MGUuc3ZnIiwiaWQiOiJoWE5EaiIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=)

在代理模式结构图中包含以下3个角色。
（1）Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，使得在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
（2）Proxy（代理主题角色）：代理主题角色内部包含了对真实主题的引用，从而可以在任何时候操作真实主题对象。在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
（3）RealSubject（真实主题角色)：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

### 简单代码实现
```java
package struct;

public class ProxyDemo {
    public static void main(String[] args) {
        Subject subject = new Proxy(new RealSubject());
        subject.request();

    }
    interface Subject {
        void request();
    }

    static class RealSubject implements Subject {
        @Override
        public void request() {
            System.out.println(">>>>> 请求真实对象 ");
        }
    }

    static class Proxy implements Subject {
        private final RealSubject realSubject;

        public Proxy(RealSubject realSubject) {
            this.realSubject = realSubject;
        }
        @Override
        public void request() {
            preRequest();
            realSubject.request();
            postRequest();
        }

        private void preRequest() {
            System.out.println(">>>> 代理 pre");
        }
        private void postRequest() {
            System.out.println(">>>> 代理 post");
        }

    }
}

```
运行结果
![image.png](https://cdn.nlark.com/yuque/0/2024/png/21883277/1706620016972-d2853045-db7a-478f-9704-ab63c1ce1fe4.png#averageHue=%23282a2d&clientId=ue0a07e22-9002-4&from=paste&height=82&id=uc1ccf549&originHeight=164&originWidth=362&originalType=binary&ratio=2&rotation=0&showTitle=false&size=16612&status=done&style=none&taskId=u3446a9e2-773e-4d73-bc41-a759b97c316&title=&width=181)
### 代理模式的种类
代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下。
（1）远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。远程代理又称为大使（Ambassador）。
（2）虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
（3）保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
（4）缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
（5）智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。

### 代理模式与装饰模式的区别
代理模式和装饰模式在实现时有些类似，但是代理模式主要是给真实主题类增加一些全新的职责，例如权限控制、缓冲处理、智能引用、远程访问等，这些职责与原有职责不属于同一个问题域。
而装饰模式是通过装饰类为具体构件类增加一些相关的职责，是对原有职责的扩展，这些职责属于同一问题域。代理模式和装饰模式的目的也不相同，前者是控制对对象的访问，而后者是为对象动态地增加功能。
### 代理模式总结
#### 代理模式的主要优点如下：
（1）代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度，满足迪米特法则。
（2）客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。
（3）远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。
（4）虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。
（5）保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。

#### 代理模式的主要缺点如下：
（1）由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。
（2）实现代理模式需要额外的工作，有些代理模式的实现非常复杂，例如远程代理。

### 适用场景
代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合。
（1）当客户端对象需要访问远程主机中的对象时，可以使用远程代理。
（2）当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时，可以使用虚拟代理。例如一个对象需要很长时间才能完成加载时。
（3）当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时，可以使用保护代理。
（4）当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时，可以使用缓冲代理。通过缓冲代理，系统无须在客户端每次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。
（5）当需要为一个对象的访问（引用）提供一些额外的操作时，可以使用智能引用代理。
# 表现型

