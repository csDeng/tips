# 基础知识
## 1. 指针占用几个字节
首先指针代表着地址，也就意味着一个指针占用几个字节，等于是一个地址的内存单元编号有多长。所以结论是：
一个指针在32位的计算机上，占4个字节；
一个指针在64位的计算机上，占8个字节。

## 2. struct 在 C/C++ 中有什么区别
### C 语言

- Struct是用户自定义数据类型（UDT）。
- C中的struct是没有权限设置的。
- C中的struct只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。
- struct中间的某个类型（例如int）不可以直接初始化。
### C++

- Struct是抽象数据类型（ADT），支持成员函数的定义。
- C++中struct增加了访问权限,且可以和类一样有成员函数。 
- C++中的struct等同于class，只是class默认成员权限是private，而struct默认成员权限是public。
- C++ struct里面成员初始化的形式和类是相同的，不可以直接初始化，就是不可以定义成员的时候同时初始化。

## 3. 堆内存申请的方式
####  malloc
#### calloc
#### realloc
#### new 
## 4. malloc 与 new 有什么区别

## 5. 指针和指针变量有什么区别
首先，数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。
所以主要区别有以下几点：

1. “指针”是概念，“指针变量”是具体实现。指针也是一个变量，所以需要我们进行定义，而对于指针的定义，与一般变量一样。
2. 一个变量的(内存)地址称为该变量的“指针”，通过指针能找到以它为地址的内存单元。而指针变量是用来存放另一个变量的地址的（即指针）。
3. 指针和指针变量是两个不同的概念，但要注意的是，通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。

## 6. 野指针、智能指针、悬空指针、空指针
### 野指针

- 野指针就是未进行初始化的指针，你不知道这个指针变量里面的内容是什么
### 悬空指针

- 悬空指针就是将这个指针指向的内存已经释放了，却没有对指针进行赋空，因为C++并没有垃圾回收机制，你`delete`了一个指针只是释放了指针指向的内存空间，而指针本身依旧还在，正确的操作是delete一个指针后立马将指针赋值为 `nullptr`。
### 智能指针
> 智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。

所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。
> C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。

### 空指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。
## 7. 在C++中，struct 与 class 有什么区别
class 和 struct 最本质的区别 : class 是引用类型，它在堆中分配空间，栈中保存的只是引用；而 struct 是值类型，它在栈中分配空间。

## 8. 智能指针的分类

1. **unique_ptr**：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。

![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668142836167-e3e9cb30-e4d7-4299-b34b-f7eeb91c543c.png#averageHue=%23fceec5&clientId=u985baad6-f751-4&from=paste&id=uc631e552&originHeight=231&originWidth=311&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4442dd4a-6f47-4b38-9aff-eb43a5dcb46&title=)

2. **shared_ptr**：与 unique_ptr 不同的是，shared_ptr 中资源可以被多个指针共享，但是多个指针指向同一个资源不能被释放多次，因此使用计数机制表明资源被几个指针共享。

![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668142850534-42a7d5ee-dca5-43c7-95a9-2d51c20c6bd4.png#averageHue=%23fceec5&clientId=u985baad6-f751-4&from=paste&id=u84dd568e&originHeight=231&originWidth=311&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udf055254-76e2-4d6d-9c99-4cdbae836f6&title=)

3. **weak_ptr**：指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的循环引用问题。与 shared_ptr 配合使用，将 weak_ptr 转换为 share_ptr 时，虽然它能访问 share_ptr 所指向的资源但却不享有资源的所有权，不影响该资源的引用计数。有可能资源已被释放，但 weak_ptr 仍然存在，share_ptr 必须等待所有引用的 weak_ptr 全部被释放才会进行释放。因此每次访问资源时都需要判断资源是否有效。

![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668142860211-8c96f2df-3c0e-4a30-975f-40cebc6094ca.png#averageHue=%23f8f6f3&clientId=u985baad6-f751-4&from=paste&id=uc7d6bee9&originHeight=231&originWidth=395&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4b7631ad-b820-40f4-8bd7-2879a412556&title=)


## 9. `include " "` 和 `<> `的区别
include 关键字主要用来标识 C/C++ 程序源代码编译时需要引用的头文件，编译器会自动去查找这些头文件中的变量、函数声明、结构体定义等相关信息，常见的有 `include <filename>` 和 `#include "filename"`，二者之间的主要区别在查找文件的位置。

- `include<filename>` 通常在编译器或者 IDE 中预先指定的搜索目录中进行搜索，通常会搜索 `/usr/include` 目录，此方法通常用于包括标准库头文件；
- `include "filename"` 在当前源文件所在目录中进行查找，如果没有；再到当前已经添加的系统目录（编译时以 -I 指定的目录）中查找，最后会在 `/usr/include`  目录下查找 。

日常编写程序时，对于标准库中的头文件常用 `include<filename>`，对于自己定义的头文件常用` #include "filename"`。

# STL

## 序列化容器


## 关联容器


## 无序关联容器



# 网络 IO 模型
堵塞和非堵塞的概念描述的是用户线程调用内核 IO 操作的方式。

- 堵塞是指 IO 操作需要彻底完成后才返回到用户空间；
- 非堵塞是指 IO 操作被调用后立即返回给客户一个状态值，不需要等到 IO 操作彻底完成。
## 1. 堵塞IO

## 2. 非堵塞IO

## 3. IO 多路复用
参考【小林 coding】
### select/poll
select 实现多路复用的方式是，将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。
所以，对于 select 这种方式，需要进行 **2 次「遍历」文件描述符集合**，一次是在内核态里，一次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。
poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。
但是 poll 和 select 并没有太大的本质区别，**都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着并发数上来，性能的损耗会呈指数级增长。


## epoll
先复习下 epoll 的用法。如下的代码中，先用 `epoll_create` 创建一个 `epoll`对象 `epfd`，再通过 `epoll_ctl` 将需要监视的 `socket` 添加到 `epfd`中，最后调用 `epoll_wait` 等待数据。
```cpp
int s = socket(AF_INET, SOCK_STREAM, 0);
bind(s, ...);
listen(s, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

while(1) {
    int n = epoll_wait(...);
    for(接收到数据的socket){
        //处理
    }
}
```
epoll 通过两个方面，很好解决了 select/poll 的问题。
_第一点_，epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。
_第二点_， epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。
从下图你可以看到 epoll 相关的接口作用：
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1665731027535-e166aecb-8ca5-4270-b040-21b8659e6746.png#averageHue=%23edf1d3&clientId=u9afd8c0f-465c-4&errorMessage=unknown%20error&from=paste&id=uc2f19806&originHeight=527&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=uc4ca6811-9c76-4487-a550-1d73997c1fc&title=)
epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，**epoll 被称为解决 C10K 问题的利器**。
插个题外话，网上文章不少说，epoll_wait 返回时，对于就绪的事件，epoll 使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。
这是错的！看过 epoll 内核源码的都知道，**压根就没有使用共享内存这个玩意**。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 __put_user 函数，这个函数就是将数据从内核拷贝到用户空间。
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1665731027557-8af17c33-d357-4bf7-a7ff-71413a81c947.png#averageHue=%232d2c55&clientId=u9afd8c0f-465c-4&errorMessage=unknown%20error&from=paste&id=ub80a437d&originHeight=472&originWidth=876&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=uc118bed1-2abd-4064-9ba7-c0430a9bcde&title=)
好了，这个题外话就说到这了，我们继续！
### 边缘触发和水平触发
epoll 支持两种事件触发模式，分别是**边缘触发（_edge-triggered，ET_）和水平触发（_level-triggered，LT_）**。
这两个术语还挺抽象的，其实它们的区别还是很好理解的。

- 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；
- 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。
如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。
如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会**循环**从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，**边缘触发模式一般和非阻塞 I/O 搭配使用**，程序会一直执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK。
一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。
select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。
另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：
Under Linux, select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.
我谷歌翻译的结果：
在Linux下，select() 可能会将一个 socket 文件描述符报告为 "准备读取"，而后续的读取块却没有。例如，当数据已经到达，但经检查后发现有错误的校验和而被丢弃时，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 O_NONBLOCK 可能更安全。
简单点理解，就是**多路复用 API 返回的事件并不一定可读写的**，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。

## 4. 异步IO


# 编译与内存相关
## 编译与链接
### 1. 为什么需要编译
我们常见的 `C/C++` 语言，`CPU` 是无法理解的，这就需要将我们编写好的代码最终翻译为机器可执行的二进制指令，编译的过程本质上也即是翻译的过程。

###  2. 编译的处理过程
编译器读取源文件 cpp，并将其翻译为可执行文件「\texttt{ELF}ELF」，\texttt{ELF}ELF 文件可以经过操作系统进行加载执行。常见的编译过程分为四个过程：编译预处理、编译、汇编、链接。
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668140520245-559219f7-8482-4ae3-a6c4-64fdd30ae4f7.png#averageHue=%23f7f3f0&clientId=u985baad6-f751-4&from=paste&id=uf2c785e4&originHeight=180&originWidth=795&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uad50c7bb-f6fa-4df2-ad26-316f784c8f6&title=)
**编译预处理**：在预编译过程中主要处理源代码中的预处理指令，比如引入头文件（`#include`），去除注释，处理所有的条件编译指令（`#ifdef, #ifndef, #else, #elif, #endif`），宏的替换（`#define`），添加行号，保留所有的编译器指令；
**编译：**针对预处理后的文件进行词法分析、语法分析、语义分析、符号汇总、汇编代码生成，并针对程序的结构或者特定的 `CPU` 平台进行优化，其中涉及的过程较为复杂。简单来说编译的过程即为将` .cpp `源文件翻译成 `.s `的汇编代码；
**汇编：**将汇编代码` .s `翻译成机器指令 `.o `文件，一个 `.cpp` 文件只会生成一个 `.o` 文件；
**链接：**汇编程序生成的目标文件即为 `.o` 文件，单独的 `.o` 文件可能无法执行。因为一个程序可能由多个源文件组成，此时就存在多个 `.o` 文件。文件 A 中的函数引用了另一个文件 B 中定义的符号或者调用了某个库文件中的函数，这就需要链接处理。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成一个可被操作系统加载执行的 `ELF` 程序文件。


## 内存管理
### 1. ELF 文件
可执行与可链接格式 (`Executable and Linkable Format`) 是一种用于可执行文件、目标代码、共享库和核心转储 （core dump） 的标准文件格式，每个 `ELF` 文件都由一个 `ELF header` 和紧跟其后的文件数据部分组成，可以参考 ELF 文件的构成如下:
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668140844612-9e95d7d0-1932-4f78-b682-0a6ed8072718.png#averageHue=%23dcc216&clientId=u985baad6-f751-4&from=paste&id=u020cfc76&originHeight=521&originWidth=597&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf33be543-8010-4fe7-9af6-4e422b7c571&title=)
我们可以看到可执行程序内部都是分段进行存储的。

- `.text section`：代码段。通常存放已编译程序的机器代码，一般操作系统加载后，这部分是只读的。
- `.rodatasection`：只读数据段。此段的数据不可修改，存放程序中会使用的常量。比如程序中的常量字符串 "aasdasdaaasdasd"。
- `.datasection`：数据段。主要用于存放已初始化的全局变量、常量。
- `.bsssection`: bss 段。该段主要存储未初始化全局变量，仅是占位符，不占据任何实际磁盘空间。目标文件格式区分初始化和非初始化是为了空间效率。

操作系统在加载 ELF 文件时会将按照标准依次读取每个段中的内容，并将其加载到内存中，同时为该进程分配栈空间，并将 pc 寄存器指向代码段的起始位置，然后启动进程。

### 2. 内存分区
C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局/静态存储区、常量存储区、代码区。

- 栈：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的局部变量、函数参数、返回地址等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。
- 堆：动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。我们可以利用。
- 全局区/静态存储区：主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- 常量存储区：`.rodata` 段，存放的是常量，不允许修改，程序运行结束自动释放。
- 代码区：`.text `段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

我们参考常见的Linux 操作系统下的内存分布图如下:
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668141169076-b0a9c110-0714-47f1-bc4b-64b23a3bc141.png#averageHue=%23fcfbfa&clientId=u985baad6-f751-4&from=paste&id=u34999efa&originHeight=658&originWidth=543&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udf1e532e-80b6-4ba0-9dc8-0af7373ffdd&title=)
 从操作系统的本身来讲，以上存储区在该程序内存中的虚拟地址分布是如下形式（虚拟地址从低地址到高地址，实际的物理地址可能是随机的）：`.text→.data→.bss→heap→unused→stack→⋯`。
```cpp
#include <iostream>
using namespace std;
/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/
int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}

```

## 变量定义与生命周期
C/C++ 变量有两个非常重要的属性：作用域与生命周期，这两个属性代表从时间和空间两个不同的维度来描述一个变量。

### 1. 作用域
作用域即一个变量可以被引用的范围，常见的作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。从作用域来来看：

1. 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用 `extern` 关键字再次声明这个全局变量。
2. 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
3. 局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回，局部变量对于函数外部的程序来说是不可见的。当然内部实际更复杂，实际是以 `{} `为作用域的。
4. 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见, 只有定义该变量的函数内部可以使用访问和修改该变量。

**程序实例**：
以下为详细的程序实例 a.cpp, b.cpp，分别对应的变量定义。

- `a.cpp`
```cpp
#include <iostream>
using namespace std;
int g_var = 0; // 全局变量
static char *gs_var;  // 静态全局变量

int main()
{
    int var;                    // 局部变量
    static int s_var = 0;       // 静态局部变量
    return 0;
}

```

- `b.cpp`
```cpp
#include <iostream>
using namespace std;
extern int g_var = 0; // 访问全局变量
// extern static char *gs_var;  无法访问静态全局变量

int test()
{
    g_var = 1;
}

```

### 2. 生命周期
生命周期即该变量可以被引用的时间段（生存期表示变量存在的时间）。

- 全局变量: 全局变量在整个程序运行期间都会一直存在，都可以随时访问，当程序结束时，对应的变量则会自动销毁，内存会被系统回收。
- 局部变量: 局部变量的生命周期仅限于函数被调用期间，当函数调用结束时，该变量会自动销毁。
- 静态局部变量：实际上静态局部变量的作用域仅限于函数内部，它的作用域与局部变量相同，但实际上该变量在程序运行期间是一直存在的，生命周期贯穿于整个程序运行期间。局部静态变量只能被初始化一次。

> 注意：
> - 静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：
> 
静态变量会被放在程序的静态数据存储区（.data 段，bss 段，rodata 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。
> - 静态变量和全局变量的区别：
> 
静态变量仅在变量的作用范围内可见，实际是依靠编译器来控制作用域。全局变量在整个程序范围内都可可见，只需声明该全局变量，即可使用。
> - 全局变量定义在不要在头文件中定义：
> 
如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错，因此不能再头文件中定义全局变量。一般情况下我们将变量的定义放在 .cpp 文件中，一般在 .h 文件使用extern 对变量进行声明。


## 大端与小端
### 1. 字节序
在 C 语言中，一个类型为 int 的变量 x 地址为 `0x100`，那么其对应地址表达式 `&x` 的值为 `0x100`，x 的四个字节将被存储在电脑内存的 `0x100，0x101，0x102，0x103` 位置。字节的排列方式常见的方式有两种：将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序（Little-Endian）；反之则称大端序（Big-Endian）。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668142056579-f7466874-455e-4611-aae4-dbbd7eb97051.png#averageHue=%23efefef&clientId=u985baad6-f751-4&from=paste&height=740&id=u9f104278&originHeight=740&originWidth=1518&originalType=binary&ratio=1&rotation=0&showTitle=false&size=168365&status=done&style=none&taskId=u67b20217-fbdc-4f3d-8838-2278745cd43&title=&width=1518)
### 2. 为什么需要字节序
主要是因为在网络应用中字节序是一个必须被考虑的因素，对于不同 CPU 可能采用不同标准的字节序，所以均按照网络标准转化成相应的字节序。

### 3. 小端（`Little-Endian`）
将低序字节存储在起始地址（低位编址），在变量指针转换的时候地址保持不变，比如 int64* 转到 int32*，对于机器计算来说更友好和自然。
### 4. 大端（`Big-Endian`）
将高序字节存储在起始地址（高位编址），内存顺序和数字的书写顺序是一致的，对于人的直观思维比较容易理解，网络字节序统一规定采用 Big-Endian。

## 内存泄漏
程序在堆中申请的动态内存，在程序使用完成时没有得到及时的释放。当这些变量的生命周期已结束时，该变量在堆中所占用的内存未能得到释放，从而就导致了堆中可使用的内存越来越少，最终可能产生系统运行较慢或者系统因内存不足而崩溃的问题。

> 注意：
> - 内存泄漏并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。
> - 内存泄漏主要指堆上分配的变量，因为栈中分配的变量，随着函数退出时会自动回收。而堆是动态分配的，一旦用户申请了内存分配而为及时释放，那么该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存。
> - 对于实际的程序来说，我们在调用过程中使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。当然在实际应用中，我们可能在使用系统资源或者在堆中创建对象时，没有及时将这些资源或者对象进行释放时，也会造成内存泄漏，这些资源或者对象的创建实际也占用了堆中的内存，在使用完成时应及时将其进行释放。
> 


