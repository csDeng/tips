# 链表
## 单向链表

## 双向链表

## 循环链表

## 跳跃表
![Skip_list_add_element-en.gif](https://cdn.nlark.com/yuque/0/2022/gif/21883277/1665723773703-414bb0f3-da95-4ac8-ad68-abe340762325.gif#averageHue=%23f5f5f5&clientId=uc12c8ad0-cfae-4&from=ui&id=u42551275&originHeight=332&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49035&status=done&style=none&taskId=u1b22d0fe-8f88-4273-be4a-0d9073f7f71&title=)
## 快表

## 压缩表







# 树
## 二叉树


## 二叉搜索树(`BST`)
> (`Binary Search Tree`) ,别名二叉排序树（`Binary Sort Tree`）

是指一棵空树或者具有下列性质的二叉树：

1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
### 增
向一个二叉查找树b中插入一个节点s的算法，过程为：

1. 若b是空树，则将s所指节点作为根节点插入，否则：
2. 若`s.val == b.val`，则返回，否则：
3. 若`s.val < b.val`，则把s所指节点插入到左子树中，否则：
4. 把s所指节点插入到右子树中。（新插入节点总是叶子节点）
```cpp
/* 当二叉查找树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，否则返回 FALSE */
Status InsertBST(BiTree *&T, ElemType e) {
    if (!T) {
        s = new BiTNode;
        s->data = e;
        s->lchild = s->rchild = NULL;
        T = s; // 被插節点*s为新的根结点
    } else if (e.key == T->data.key)
        return false;// 关键字等于e.key的数据元素，返回錯誤
    if (e.key < T->data.key)
        InsertBST(T->lchild, e);  // 將 e 插入左子樹
    else
        InsertBST(T->rchild, e);  // 將 e 插入右子樹
    return true;
}
```
### 删
在二叉查找树删去一个结点，分三种情况讨论：

1. 若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
2. 若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）或右子树（当*p是右子树）即可，作此修改也不破坏二叉查找树的特性。
3. 若*p结点的左子树和右子树均不空。在删去*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21883277/1665723512651-9106a0c9-05f1-4a0d-bf06-7455bbdeaad6.png#averageHue=%23010000&clientId=uc12c8ad0-cfae-4&from=paste&id=ubdcb05df&originHeight=546&originWidth=1920&originalType=url&ratio=1&rotation=0&showTitle=false&size=129674&status=done&style=none&taskId=uf7de1788-7342-4eff-b6df-3df5e03c209&title=)

- 其一是令*p的左子树为*f的左/右（依*p是*f的左子树还是右子树而定）子树，*s为*p左子树的最右下的结点，而*p的右子树为*s的右子树；
- 其二是令*p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代*p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。
### 查
在二叉查找树b中查找x的过程为：

1. 若b是空树，则搜索失败，否则：
2. 若`x == b.val`，则查找成功；否则：
3. 若 `x < b.val`，则搜索左子树；否则：
4. 查找右子树。

## AVL 树
## 性质

1. 空二叉树是一个 AVL 树
2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且`h(ls) - h(rs) ≤ 1 ` ，h 是其左右子树的高度。
3. 树高为 `O(logn)`

平衡因子：右子树高度 - 左子树高度

## Trie Tree 前缀树
### 什么是前缀树
前缀树 是 N叉树 的一种特殊形式。通常来说，一个前缀树是用来 存储字符串 的。前缀树的每一个节点代表一个 字符串（前缀）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的 原始字符串 ，以及 通往该子节点路径上所有的字符 组成的。
下面是前缀树的一个例子：
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1668080120665-4aaa3d49-d566-400e-a746-3f279e242ce9.png#averageHue=%23fdfdfd&clientId=u7b6c5373-c9bf-4&from=paste&id=u3e73b9c5&originHeight=812&originWidth=786&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7bbcabe0-c084-4ca2-8232-f34f5c9e54b&title=)
在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 'b'，然后选择它的第一个子节点 'a'，接下来继续选择子节点 'd'，我们最终会到达叶节点 "bad"。节点的值是由从根节点开始，与其经过的路径中的字符按顺序形成的。
值得注意的是，根节点表示 空字符串 。
前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是 前缀树 名称的由来。
我们再来看这个例子。例如，以节点 "b" 为根的子树中的节点表示的字符串，都具有共同的前缀 "b"。反之亦然，具有公共前缀 "b" 的字符串，全部位于以 "b" 为根的子树中，并且具有不同前缀的字符串来自不同的分支。
前缀树有着广泛的应用，例如自动补全，拼写检查等等。

### 前缀树如何表示
#### 数组
第一种方法是用 数组 存储子节点。
例如，如果我们只存储含有字母 a 到 z 的字符串，我们可以在每个节点中声明一个大小为 26 的数组来存储其子节点。对于特定字符 c ，我们可以使用 c - 'a' 作为索引来查找数组中相应的子节点。
```java
class TrieNode {
    // change this value to adapt to different cases
    public static final int N = 26;
    public TrieNode[] children = new TrieNode[N];
    
    // you might need some extra values according to different cases
};

/** Usage:
 *  Initialization: TrieNode root = new TrieNode();
 *  Return a specific child node with char c: root.children[c - 'a']
 */

```
访问子节点十分 快捷 。访问一个特定的子节点比较 容易 ，因为在大多数情况下，我们很容易将一个字符转换为索引。但并非所有的子节点都需要这样的操作，所以这可能会导致 空间的浪费 。

#### Map
第二种方法是使用 Hashmap 来存储子节点。
我们可以在每个节点中声明一个 Hashmap 。Hashmap 的键是字符，值是相对应的子节点。
```java
class TrieNode {
    public Map<Character, TrieNode> children = new HashMap<>();
    
    // you might need some extra values according to different cases
};

/** Usage:
 *  Initialization: TrieNode root = new TrieNode();
 *  Return a specific child node with char c: root.children.get(c)
 */

```
通过相应的字符来访问特定的子节点 更为容易 。但它可能比使用数组 稍慢一些 。但是，由于我们只存储我们需要的子节点，因此 节省了空间 。这个方法也更加 灵活 ，因为我们不受到固定长度和固定范围的限制。
> 补充
> 我们已经提到过如何表示前缀树中的子节点。除此之外，我们也需要用到一些其他的值。
> 例如，我们知道，前缀树的每个节点表示一个字符串，但并不是所有由前缀树表示的字符串都是有意义的。如果我们只想在前缀树中存储单词，那么我们可能需要在每个节点中声明一个布尔值（Boolean）作为标志，来表明该节点所表示的字符串是否为一个单词。


### 实现
```java
class Trie {
    class TrieNode {
        public static final int N = 26;
        public TrieNode[] children = new TrieNode[N];
        public boolean isWord = false;
        public TrieNode(){}
    }
    private TrieNode root; 

    public Trie() {
        root = new TrieNode();
    }

    // 插入
    public void insert(String word) {
        TrieNode last = lastChar(word, true);
        last.isWord = true;
    }

    // 搜索
    public boolean search(String word) {
        TrieNode last = lastChar(word, false);
        if( last == null ) {
            return false;
        }
        return last.isWord;
    }

    // 前缀
    public boolean startsWith(String prefix) {
        return lastChar(prefix, false) != null ;
    }

    /**
	* 获取最后一个节点
	**/
    private TrieNode lastChar(String word, boolean isInsert) {
        TrieNode head = root;
        int idx;
        for(int i=0, l = word.length(); i<l; ++i) {
            idx = word.charAt(i) - 'a';
            if(head.children[idx] == null ) {
                if( !isInsert) {
                    return null;
                }
                head.children[idx] = new TrieNode();
            }
            head = head.children[idx];
        } 
        return head;
    }

}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

## B 树
在计算机科学中，B 树（B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。
在 B 树中，有两种节点：

1. 内部节点（internal node）：存储了数据以及指向其子节点的指针。
2. 叶子节点（leaf node）：与内部节点不同的是，叶子节点只存储数据，并没有子节点。
### 性质
[B 树 - OI Wiki](https://oi-wiki.org/ds/b-tree/)
一个简单的图例如下：
![](https://cdn.nlark.com/yuque/0/2022/svg/21883277/1665724450652-287fe1b0-6182-4045-a6d0-d42a0e6abaa6.svg#clientId=uc12c8ad0-cfae-4&from=paste&id=uf0f2da29&originHeight=231&originWidth=831&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf58a1bea-754c-48ef-817e-5e0a0aec68a&title=)

 
## B+ 树
[B+ 树 - OI Wiki](https://oi-wiki.org/ds/bplus-tree/)
B+ 树是 B 树 的一个升级，它比 B 树更适合实际应用中操作系统的文件索引和数据库索引。目前现代关系型数据库最广泛的支持索引结构就是 B+ 树。
B+ 树是一种多叉排序树，即每个节点通常有多个孩子。一棵 B+ 树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。
B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。
![](https://cdn.nlark.com/yuque/0/2022/png/21883277/1665724645754-8dfa421d-6706-448d-95fe-b41f82fdcd6c.png#averageHue=%23ebe9e6&clientId=uc12c8ad0-cfae-4&from=paste&id=u1287d973&originHeight=516&originWidth=1121&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud20f680d-1626-4e2c-a6a3-e589470b424&title=)
## B+ 树相比于 B 树的优势
由于索引节点上只有索引而没有数据，所以索引节点上能存储比 B 树更多的索引，这样树的高度就会更矮。树的高度越矮，磁盘寻道的次数就会越少。
因为数据都集中在叶子节点，而所有叶子节点的高度相同，那么可以在叶子节点中增加前后指针，指向同一个父节点的相邻兄弟节点，这样可以更好地支持查询一个值的前驱或后继，使连续访问更容易实现。
比如这样的 SQL 语句：select * from tbl where t > 10，如果使用 B+ 树存储数据的话，可以首先定位到数据为 10 的节点，再沿着它的 next 指针一路找到所有在该叶子节点右边的叶子节点，返回这些节点包含的数据。
而如果使用 B 树结构，由于数据既可以存储在内部节点也可以存储在叶子节点，连续访问的实现会更加繁琐（需要在树的内部结构中进行移动）。
## 多路平衡二叉树


## 红黑树

### 红黑树的性质
红黑树是每个节点都带有_颜色_属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 不存在两个相邻的红色节点，相邻指两个节点是父子关系。
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

下面是一个具体的红黑树的图例：
[![image.png](https://cdn.nlark.com/yuque/0/2022/png/21883277/1665721817800-12e8c9f6-4426-4331-89a8-6e0d740ebd7d.png#averageHue=%230b0202&clientId=uc12c8ad0-cfae-4&from=paste&id=ud69c783c&originHeight=220&originWidth=450&originalType=url&ratio=1&rotation=0&showTitle=false&size=23780&status=done&style=none&taskId=ud1c6c3e9-93f5-4045-adf2-e5ff964b6c0&title=)](https://zh.wikipedia.org/wiki/File:Red-black_tree_example.svg)

### 操作
红黑树上的只读操作与普通二叉查找树上的只读操作相同。
然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。
恢复红黑树的性质需要少量的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。
#### 插入

#### 删除

# 图



# 堆



